%YAML 1.2
---
name: XPath 1.0
scope: text.xpath # http://www.w3.org/TR/xpath/
variables:
  QName: '(?![\d.\-])[\w.\-]+'
  Prefix: '(?:({{QName}})(\s*)(:))?'
  NCName: '{{Prefix}}(?:({{QName}})|(\*))'
  Attribute: '(@)(\s*)(?:{{NCName}})?'
contexts:
  main:
    - match: '#.*$'
      scope: syntax-test.marker.xpath # needed to get syntax tests working properly, otherwise it treats the syntax test definition line as an xpath... https://github.com/SublimeTextIssues/Core/issues/1152
    - match: '\]|\)'
      scope: invalid.illegal.stray-bracket-end.xpath
    - match: ''
      push: base

  base_excluding_string:
    - include: location_step
    - match: '-*\('
      scope: punctuation.section.group.begin.xpath
      set: [inside_subexpression, base_disallow_pop] # don't allow an opening parenthesis followed immediately by a closing parenthesis
    - match: '\$({{QName}})?'
      scope: variable.other.xpath # VariableReference
      set: operator_or_predicate_or_location_step
    - include: location_test

  base_without_pop:
    - match: '"'
      scope: punctuation.definition.string.begin.xpath
      set: [operator, inside_string_double]
    - match: "'"
      scope: punctuation.definition.string.begin.xpath
      set: [operator, inside_string_single]
    - match: '-*(?:\d+\.\d*|\.?\d+)' # lxml allows '2', '2.', '.5', '2.5' and '---3' for example - '2.' is treated as '2.0'
      scope: constant.numeric.xpath # Number
      set: operator
    - include: base_excluding_string

  inside_string_double:
    - meta_scope: string.quoted.double.xpath # Literal
    - match: '"'
      scope: punctuation.definition.string.end.xpath
      pop: true

  inside_string_single:
    - meta_scope: string.quoted.single.xpath # Literal
    - match: "'"
      scope: punctuation.definition.string.end.xpath
      pop: true

  inside_subexpression:
    - meta_scope: meta.group.xpath
    - match: '\)'
      scope: punctuation.section.group.end.xpath
      set: operator_or_predicate_or_location_step

  base:
    - include: pop_me
    - include: base_without_pop
    - include: unexpected_token

  location_step:
    - match: '/{1,2}'
      scope: punctuation.separator.location-step.xpath
      set: location_test_or_invalid

  axis_step:
    - match: '\.{1,2}'
      scope: variable.parameter.xpath # AxisStep
      set: operator_or_location_step

  base_disallow_pop:
    - include: base_without_pop
    - match: '[,\]\)]'
      scope: invalid.illegal.unexpected-token.xpath

  pop_me:
    - match: '(?=[,\]\)])'
      pop: true

  operator:
    - match: 'and|or|mod|div'
      scope: keyword.operator.word.xpath # Operator https://forum.sublimetext.com/t/dev-build-3110/19214/31
      set: base_disallow_pop # show invalid end predicate when an operator is at the end of a predicate for example //*[a or ]
    - match: '\*|\||\+|-|!?=|<=?|>=?'
      scope: keyword.operator.xpath # Operator
      set: base_disallow_pop # show invalid end predicate when an operator is at the end of a predicate for example //*[a or ]
    - include: pop_me
    - include: unexpected_token

  operator_or_predicate:
    - match: '(\[)(\d+)(\])'
      captures:
        1: meta.item-access.array.xpath punctuation.section.brackets.begin.xpath
        2: meta.item-access.arguments.array-index.xpath constant.numeric.xpath # Number
        3: meta.item-access.array.xpath punctuation.section.brackets.end.xpath
    - match: '\['
      scope: meta.item-access.array.xpath punctuation.section.brackets.begin.xpath
      set: [inside_predicate, base_disallow_pop]
    - include: operator

  operator_or_predicate_or_location_step:
    - include: location_step
    - include: operator_or_predicate

  operator_or_location_step:
    - include: location_step
    - include: operator

  inside_predicate:
    - meta_content_scope: meta.item-access.arguments.xpath
    - match: '\]'
      scope: meta.item-access.array.xpath punctuation.section.brackets.end.xpath
      set: operator_or_predicate_or_location_step
    - include: unexpected_token

  node_type:
    - match: '(comment|text|processing-instruction|node)\s*\(\s*\)'
      scope: storage.type.node-type.xpath # NodeType
      set: operator_or_predicate_or_location_step

  name_test:
    - match: '{{NCName}}'
      captures: # NameTest
        1: entity.name.tag.namespace.xpath
        2: entity.name.tag.xpath whitespace.xpath
        3: entity.name.tag.xpath punctuation.separator.namespace.xpath
        4: entity.name.tag.localname.xpath
        5: variable.parameter.xpath
      set: operator_or_predicate_or_location_step

  node_test:
    - include: node_type
    - include: name_test

  node_test_or_invalid:
    - include: node_test
    - include: unexpected_token

  location_test:
    - match: '{{Attribute}}'
      captures:
        1: entity.other.attribute-name.xpath punctuation.definition.attribute.xpath
        2: entity.other.attribute-name.xpath whitespace.xpath
        3: entity.other.attribute-name.namespace.xpath
        4: entity.other.attribute-name.xpath whitespace.xpath
        5: entity.other.attribute-name.xpath punctuation.separator.namespace.xpath
        6: entity.other.attribute-name.localname.xpath
        7: variable.parameter.xpath
      set: operator_or_predicate_or_location_step
    - match: '((?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|namespace|parent|preceding(?:-sibling)?|self)\s*::)\s*'
      captures:
        1: constant.language.axis-name.xpath # AxisName
      set: node_test_or_invalid
    - include: node_type
    - match: '(tokenize|matches)\s*(\()'
      captures:
        1: support.function.localname.xpath # NameTest 
        2: punctuation.section.arguments.begin.xpath
      set: [inside_function_regex, pop_at_comma]
    - match: '{{Prefix}}({{QName}})\s*(\()'
      captures:
        1: support.function.namespace.xpath
        2: support.function.xpath whitespace.xpath
        3: support.function.xpath punctuation.separator.namespace.xpath
        4: support.function.localname.xpath # NameTest 
        5: punctuation.section.arguments.begin.xpath
      set: [inside_function, base]
    - include: name_test
    - include: axis_step

  location_test_or_invalid:
    - include: location_test
    - include: unexpected_token

  pop_at_comma:
    - match: ','
      scope: punctuation.separator.parameters.xpath
      pop: true
    - include: base

  inside_function:
    - meta_scope: meta.function-call.xpath
    - meta_content_scope: meta.function-call.arguments.xpath
    - match: '\)'
      scope: punctuation.section.arguments.end.xpath
      set: operator_or_predicate_or_location_step
    - match: ','
      scope: punctuation.separator.parameters.xpath
      push: base

  unexpected_token:
    - match: '[)\]]'
      scope: invalid.illegal.stray-bracket-end.xpath
    - match: '\S+'
      scope: invalid.illegal.unexpected-token.xpath

  inside_function_regex:
    - meta_scope: meta.function-call.xpath
    - meta_content_scope: meta.function-call.arguments.xpath
    - match: '\)'
      scope: punctuation.section.arguments.end.xpath
      set: operator_or_predicate_or_location_step
    - match: ','
      scope: punctuation.separator.parameters.xpath
      set:
        - meta_content_scope: meta.function-call.xpath meta.function-call.arguments.xpath
        - match: "'"
          scope: punctuation.definition.string.begin.xpath
          push:
            - meta_scope: string.quoted.single.xpath
            - match: "'"
              scope: punctuation.definition.string.end.xpath
              set: inside_function
            - include: scope:source.regexp#base-literal
        - match: "'"
          scope: punctuation.definition.string.begin.xpath
          push:
            - meta_scope: string.quoted.double.xpath
            - match: "'"
              scope: punctuation.definition.string.end.xpath
              set: inside_function
            - include: scope:source.regexp#base-literal
    - include: base_excluding_string
